import {
  Navigate,
  useLocation
} from "./chunk-L6RTZNXR.js";
import {
  require_react
} from "./chunk-C43HOPTQ.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// client/node_modules/react-auth-kit/dist/index.modern.js
var React = __toESM(require_react());

// client/node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(key, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    key = encodeURIComponent(key).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = key + "=" + converter.write(value, key) + stringifiedAttributes;
  }
  function get(key) {
    if (typeof document === "undefined" || arguments.length && !key) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split("=");
      var value = parts.slice(1).join("=");
      try {
        var foundKey = decodeURIComponent(parts[0]);
        jar[foundKey] = converter.read(value, foundKey);
        if (key === foundKey) {
          break;
        }
      } catch (e) {
      }
    }
    return key ? jar[key] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(key, attributes) {
        set(
          key,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });
var js_cookie_default = api;

// client/node_modules/react-auth-kit/dist/index.modern.js
var AuthContext = React.createContext(null);
var AuthContextConsumer = AuthContext.Consumer;
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var TokenObject = (
  /** @class */
  function() {
    function TokenObject2(authStorageName, authStorageType, refreshTokenName, cookieDomain, cookieSecure) {
      this.authStorageType = authStorageType;
      this.authStorageName = authStorageName;
      this.authTimeStorageName = "".concat(authStorageName, "_storage");
      this.stateStorageName = "".concat(authStorageName, "_state");
      this.refreshTokenName = refreshTokenName;
      this.cookieDomain = cookieDomain;
      this.cookieSecure = cookieSecure;
      this.authStorageTypeName = "".concat(this.authStorageName, "_type");
      this.isUsingRefreshToken = !!this.refreshTokenName;
      this.refreshTokenTimeName = this.refreshTokenName ? "".concat(this.refreshTokenName, "_time") : null;
    }
    TokenObject2.prototype.initialToken = function() {
      if (this.authStorageType === "cookie") {
        return this.initialCookieToken_();
      } else {
        return this.initialLSToken_();
      }
    };
    TokenObject2.prototype.initialCookieToken_ = function() {
      var authToken = js_cookie_default.get(this.authStorageName);
      var authTokenType = js_cookie_default.get(this.authStorageTypeName);
      var authTokenTime = js_cookie_default.get(this.authTimeStorageName);
      var stateCookie = js_cookie_default.get(this.stateStorageName);
      var refreshToken = this.isUsingRefreshToken && this.refreshTokenName != null ? js_cookie_default.get(this.refreshTokenName) : null;
      var refreshTokenTime = this.isUsingRefreshToken && this.refreshTokenTimeName != null ? js_cookie_default.get(this.refreshTokenTimeName) : null;
      return this.checkTokenExist(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime);
    };
    TokenObject2.prototype.initialLSToken_ = function() {
      var authToken = localStorage.getItem(this.authStorageName);
      var authTokenType = localStorage.getItem(this.authStorageTypeName);
      var authTokenTime = localStorage.getItem(this.authTimeStorageName);
      var stateCookie = localStorage.getItem(this.stateStorageName);
      var refreshToken = this.isUsingRefreshToken && this.refreshTokenName != null ? localStorage.getItem(this.refreshTokenName) : null;
      var refreshTokenTime = this.isUsingRefreshToken && this.refreshTokenTimeName != null ? localStorage.getItem(this.refreshTokenTimeName) : null;
      return this.checkTokenExist(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime);
    };
    TokenObject2.prototype.checkTokenExist = function(authToken, authTokenType, authTokenTime, stateCookie, refreshToken, refreshTokenTime) {
      if (!!authToken && !!authTokenType && !!authTokenTime && !!stateCookie) {
        var expiresAt = new Date(authTokenTime);
        try {
          var authState = JSON.parse(stateCookie);
          var obj = {
            auth: {
              token: authToken,
              type: authTokenType,
              expiresAt
            },
            userState: authState,
            isSignIn: true,
            isUsingRefreshToken: this.isUsingRefreshToken,
            refresh: void 0
          };
          if (this.isUsingRefreshToken && !!refreshToken && !!refreshTokenTime) {
            var refreshTokenExpiresAt = new Date(refreshTokenTime);
            return __assign(__assign({}, obj), { refresh: {
              token: refreshToken,
              expiresAt: refreshTokenExpiresAt
            } });
          } else {
            return __assign(__assign({}, obj), { refresh: null });
          }
        } catch (e) {
          return {
            auth: null,
            refresh: null,
            userState: null,
            isUsingRefreshToken: this.isUsingRefreshToken,
            isSignIn: false
          };
        }
      } else {
        return {
          auth: null,
          refresh: null,
          userState: null,
          isUsingRefreshToken: this.isUsingRefreshToken,
          isSignIn: false
        };
      }
    };
    TokenObject2.prototype.syncTokens = function(authState) {
      if (authState.auth) {
        if (this.isUsingRefreshToken && authState.refresh) {
          this.setToken(authState.auth.token, authState.auth.type, authState.refresh.token, authState.refresh.expiresAt, authState.auth.expiresAt, authState.userState);
        } else {
          this.setToken(authState.auth.token, authState.auth.type, null, null, authState.auth.expiresAt, authState.userState);
        }
      } else {
        this.removeToken();
      }
    };
    TokenObject2.prototype.setToken = function(authToken, authTokenType, refreshToken, refreshTokenExpiresAt, expiresAt, authState) {
      if (this.authStorageType === "cookie") {
        this.setCookieToken_(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState);
      } else {
        this.setLSToken_(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState);
      }
    };
    TokenObject2.prototype.setCookieToken_ = function(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState) {
      js_cookie_default.set(this.authStorageName, authToken, {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      js_cookie_default.set(this.authStorageTypeName, authTokenType, {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      js_cookie_default.set(this.authTimeStorageName, expiresAt.toISOString(), {
        expires: expiresAt,
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      if (authState) {
        js_cookie_default.set(this.stateStorageName, JSON.stringify(authState), {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenName && !!refreshToken) {
        js_cookie_default.set(this.refreshTokenName, refreshToken, {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName && !!refreshTokenExpiresAt) {
        js_cookie_default.set(this.refreshTokenTimeName, refreshTokenExpiresAt.toISOString(), {
          expires: expiresAt,
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
    };
    TokenObject2.prototype.setLSToken_ = function(authToken, authTokenType, refreshToken, expiresAt, refreshTokenExpiresAt, authState) {
      localStorage.setItem(this.authStorageName, authToken);
      localStorage.setItem(this.authStorageTypeName, authTokenType);
      localStorage.setItem(this.authTimeStorageName, expiresAt.toISOString());
      if (authState) {
        localStorage.setItem(this.stateStorageName, JSON.stringify(authState));
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenName && !!refreshToken) {
        localStorage.setItem(this.refreshTokenName, refreshToken);
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName && !!refreshTokenExpiresAt) {
        localStorage.setItem(this.refreshTokenTimeName, refreshTokenExpiresAt.toISOString());
      }
    };
    TokenObject2.prototype.removeToken = function() {
      if (this.authStorageType === "cookie") {
        this.removeCookieToken_();
      } else {
        this.removeLSToken_();
      }
    };
    TokenObject2.prototype.removeCookieToken_ = function() {
      js_cookie_default.remove(this.authStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      js_cookie_default.remove(this.authTimeStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      js_cookie_default.remove(this.authStorageTypeName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      js_cookie_default.remove(this.stateStorageName, {
        domain: this.cookieDomain,
        secure: this.cookieSecure
      });
      if (this.isUsingRefreshToken && !!this.refreshTokenName) {
        js_cookie_default.remove(this.refreshTokenName, {
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName) {
        js_cookie_default.remove(this.refreshTokenTimeName, {
          domain: this.cookieDomain,
          secure: this.cookieSecure
        });
      }
    };
    TokenObject2.prototype.removeLSToken_ = function() {
      localStorage.removeItem(this.authStorageName);
      localStorage.removeItem(this.authTimeStorageName);
      localStorage.removeItem(this.authStorageTypeName);
      localStorage.removeItem(this.stateStorageName);
      if (this.isUsingRefreshToken && !!this.refreshTokenName) {
        localStorage.removeItem(this.refreshTokenName);
      }
      if (this.isUsingRefreshToken && !!this.refreshTokenTimeName) {
        localStorage.removeItem(this.refreshTokenTimeName);
      }
    };
    return TokenObject2;
  }()
);
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["SignIn"] = 0] = "SignIn";
  ActionType2[ActionType2["SignOut"] = 1] = "SignOut";
  ActionType2[ActionType2["RefreshToken"] = 2] = "RefreshToken";
})(ActionType || (ActionType = {}));
function authReducer(state, action) {
  switch (action.type) {
    case ActionType.SignIn:
      return __assign(__assign({}, state), { auth: action.payload.auth, refresh: action.payload.refresh, userState: action.payload.userState, isSignIn: true });
    case ActionType.SignOut:
      return __assign(__assign({}, state), { auth: null, refresh: null, userState: null, isSignIn: false });
    case ActionType.RefreshToken:
      if (state.isSignIn && state.auth && state.refresh) {
        return __assign(__assign({}, state), { auth: {
          token: action.payload.newAuthToken ? action.payload.newAuthToken : state.auth.token,
          type: state.auth.type,
          expiresAt: action.payload.newAuthTokenExpireIn ? new Date((/* @__PURE__ */ new Date()).getTime() + action.payload.newAuthTokenExpireIn * 60 * 1e3) : state.auth.expiresAt
        }, refresh: {
          token: action.payload.newRefreshToken ? action.payload.newRefreshToken : state.refresh.token,
          expiresAt: action.payload.newRefreshTokenExpiresIn ? new Date((/* @__PURE__ */ new Date()).getTime() + action.payload.newRefreshTokenExpiresIn * 60 * 1e3) : state.refresh.expiresAt
        }, userState: action.payload.newAuthUserState ? action.payload.newAuthUserState : state.userState });
      } else {
        return state;
      }
  }
}
function doSignIn(signInParams) {
  return {
    type: ActionType.SignIn,
    payload: signInParams
  };
}
function doRefresh(refreshTokenParam) {
  return {
    type: ActionType.RefreshToken,
    payload: refreshTokenParam
  };
}
function doSignOut() {
  return {
    type: ActionType.SignOut
  };
}
function useInterval(callback, delay) {
  var savedCallback = React.useRef(callback);
  var intervalRef = React.useRef(null);
  React.useEffect(function() {
    savedCallback.current = callback;
  }, [callback]);
  React.useEffect(function() {
    var tick = function() {
      return savedCallback.current();
    };
    if (typeof delay === "number") {
      intervalRef.current = window.setInterval(tick, delay * 60 * 1e3);
    }
    return function() {
      if (intervalRef.current) {
        window.clearTimeout(intervalRef.current);
      }
    };
  }, [delay]);
  return intervalRef;
}
var AuthProvider = function(_a) {
  var children = _a.children, authType = _a.authType, authName = _a.authName, cookieDomain = _a.cookieDomain, cookieSecure = _a.cookieSecure, refresh = _a.refresh;
  if (authType === "cookie") {
    if (!cookieDomain) {
      throw new Error("authType 'cookie' requires 'cookieDomain' and 'cookieSecure' props in AuthProvider");
    }
  }
  var refreshTokenName = refresh ? "".concat(authName, "_refresh") : null;
  var tokenObject = new TokenObject(authName, authType, refreshTokenName, cookieDomain, cookieSecure);
  var _b = React.useReducer(authReducer, tokenObject.initialToken()), authState = _b[0], dispatch = _b[1];
  if (refresh) {
    useInterval(function() {
      var _a2, _b2, _c, _d;
      refresh.refreshApiCallback({
        authToken: (_a2 = authState.auth) === null || _a2 === void 0 ? void 0 : _a2.token,
        authTokenExpireAt: (_b2 = authState.auth) === null || _b2 === void 0 ? void 0 : _b2.expiresAt,
        authUserState: authState.userState,
        refreshToken: (_c = authState.refresh) === null || _c === void 0 ? void 0 : _c.token,
        refreshTokenExpiresAt: (_d = authState.refresh) === null || _d === void 0 ? void 0 : _d.expiresAt
      }).then(function(result) {
        if (result.isSuccess) {
          dispatch(doRefresh(result));
        }
      });
    }, authState.isSignIn ? refresh.interval : null);
  }
  React.useEffect(function() {
    tokenObject.syncTokens(authState);
  }, [authState]);
  return React.createElement(AuthContext.Provider, { value: { authState, dispatch } }, children);
};
function createRefresh(param) {
  return param;
}
var RequireAuth = function(_a) {
  var children = _a.children, loginPath = _a.loginPath;
  var context = React.useContext(AuthContext);
  if (context === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  var isAuth = function() {
    if (context.authState.auth && new Date(context.authState.auth.expiresAt) > /* @__PURE__ */ new Date()) {
      return true;
    } else {
      context.dispatch(doSignOut());
      return false;
    }
  };
  var location = useLocation();
  if (!isAuth()) {
    return React.createElement(Navigate, { to: loginPath, state: { from: location }, replace: true });
  }
  return children;
};
function useSignIn() {
  var context = React.useContext(AuthContext);
  if (context === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function(signInConfig) {
    var token = signInConfig.token, tokenType = signInConfig.tokenType, authState = signInConfig.authState, expiresIn = signInConfig.expiresIn, refreshToken = signInConfig.refreshToken, refreshTokenExpireIn = signInConfig.refreshTokenExpireIn;
    var expTime = new Date((/* @__PURE__ */ new Date()).getTime() + expiresIn * 60 * 1e3);
    if (context.authState.isUsingRefreshToken) {
      if (!!refreshToken && !!refreshTokenExpireIn) {
        var refreshTokenExpireAt = new Date((/* @__PURE__ */ new Date()).getTime() + refreshTokenExpireIn * 60 * 1e3);
        context.dispatch(doSignIn({
          auth: {
            token,
            type: tokenType,
            expiresAt: expTime
          },
          userState: authState ? authState : null,
          refresh: {
            token: refreshToken,
            expiresAt: refreshTokenExpireAt
          }
        }));
        return true;
      } else {
        throw new Error('Make sure you given "refreshToken" and  "refreshTokenExpireIn" parameter');
      }
    } else {
      if (!!refreshToken && !!refreshTokenExpireIn) {
        throw new Error("The app doesn't implement 'refreshToken' feature.\nSo you have to implement refresh token feature from 'AuthProvider' before using it.");
      } else {
        context.dispatch(doSignIn({
          auth: {
            token,
            type: tokenType,
            expiresAt: expTime
          },
          userState: authState ? authState : null,
          refresh: null
        }));
        return true;
      }
    }
  };
}
function useSignOut() {
  var context = React.useContext(AuthContext);
  if (context === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    try {
      if (context) {
        context.dispatch(doSignOut());
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  };
}
function useAuthUser() {
  var context = React.useContext(AuthContext);
  if (context === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    return context.authState.auth ? context.authState.userState : null;
  };
}
function useAuthHeader() {
  var c = React.useContext(AuthContext);
  if (c === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    if (c.authState.auth) {
      return "".concat(c.authState.auth.type, " ").concat(c.authState.auth.token);
    } else {
      return "";
    }
  };
}
function useIsAuthenticated() {
  var context = React.useContext(AuthContext);
  if (context === null) {
    throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
  }
  return function() {
    if (context.authState.auth) {
      if (new Date(context.authState.auth.expiresAt) > /* @__PURE__ */ new Date()) {
        return true;
      } else {
        context.dispatch(doSignOut());
        return false;
      }
    } else {
      return false;
    }
  };
}
function withSignIn(Component) {
  return function(props) {
    return React.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      var signIn = function(signInConfig) {
        var token = signInConfig.token, tokenType = signInConfig.tokenType, authState = signInConfig.authState, expiresIn = signInConfig.expiresIn, refreshToken = signInConfig.refreshToken, refreshTokenExpireIn = signInConfig.refreshTokenExpireIn;
        var expTime = new Date((/* @__PURE__ */ new Date()).getTime() + expiresIn * 60 * 1e3);
        if (c.authState.isUsingRefreshToken) {
          if (!!refreshToken && !!refreshTokenExpireIn) {
            var refreshTokenExpireAt = new Date((/* @__PURE__ */ new Date()).getTime() + refreshTokenExpireIn * 60 * 1e3);
            c.dispatch(doSignIn({
              auth: {
                token,
                type: tokenType,
                expiresAt: expTime
              },
              userState: authState ? authState : null,
              refresh: {
                token: refreshToken,
                expiresAt: refreshTokenExpireAt
              }
            }));
            return true;
          } else {
            throw new Error('Make sure you given "refreshToken" and  "refreshTokenExpireIn" parameter');
          }
        } else {
          if (!!refreshToken && !!refreshTokenExpireIn) {
            throw new Error("The app doesn't implement 'refreshToken' feature.\n So you have to implement refresh token feature from 'AuthProvider' before using it.");
          } else {
            c.dispatch(doSignIn({
              auth: {
                token,
                type: tokenType,
                expiresAt: expTime
              },
              userState: authState ? authState : null,
              refresh: null
            }));
            return true;
          }
        }
      };
      return React.createElement(Component, __assign({}, props, { signIn }));
    });
  };
}
function withSignOut(Component) {
  return function(props) {
    return React.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      var signOut = function() {
        try {
          if (c) {
            c.dispatch(doSignOut());
            return true;
          } else {
            return false;
          }
        } catch (e) {
          return false;
        }
      };
      return React.createElement(Component, __assign({}, props, { signOut }));
    });
  };
}
function withAuthUser(Component) {
  return function(props) {
    return React.createElement(AuthContextConsumer, null, function(context) {
      if (context === null) {
        throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (context.authState.auth) {
        return React.createElement(Component, __assign({}, props, { authState: context.authState.userState }));
      } else {
        return React.createElement(Component, __assign({}, props, { authState: null }));
      }
    });
  };
}
function withAuthHeader(Component) {
  return function(props) {
    return React.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (c.authState.auth) {
        return React.createElement(Component, __assign({}, props, { authHeader: "".concat(c.authState.auth.type, " ").concat(c.authState.auth.token) }));
      } else {
        return React.createElement(Component, __assign({}, props, { authHeader: "" }));
      }
    });
  };
}
function withIsAuthenticated(Component) {
  return function(props) {
    return React.createElement(AuthContextConsumer, null, function(c) {
      if (c === null) {
        throw new Error("Auth Provider is missing. Please add the AuthProvider before Router");
      }
      if (c.authState.auth) {
        if (new Date(c.authState.auth.expiresAt) > /* @__PURE__ */ new Date()) {
          return React.createElement(Component, __assign({}, props, { isAuth: true }));
        } else {
          c.dispatch(doSignOut());
          return React.createElement(Component, __assign({}, props, { isAuth: false }));
        }
      } else {
        return React.createElement(Component, __assign({}, props, { isAuth: false }));
      }
    });
  };
}
AuthProvider.defaultProps = {
  cookieDomain: window.location.hostname,
  cookieSecure: window.location.protocol === "https:"
};
export {
  AuthProvider,
  RequireAuth,
  createRefresh,
  useAuthHeader,
  useAuthUser,
  useIsAuthenticated,
  useSignIn,
  useSignOut,
  withAuthHeader,
  withAuthUser,
  withIsAuthenticated,
  withSignIn,
  withSignOut
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.1 | MIT *)

react-auth-kit/dist/index.modern.js:
  (**
   *@author Arkadip Bhattacharya <in2arkadipb13@gmail.com>
   *@fileoverview Sign In functionality <hook>
   *@copyright Arkadip Bhattacharya 2020
   *@license Apache-2.0
   *
   * Copyright 2020 Arkadip Bhattacharya
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *         http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=react-auth-kit.js.map
